use crate::compiler::tokens::{Token, LexicalError};
use crate::compiler::semantic_cube;
use crate::compiler::semantic_tables;
use std::collections::HashMap;
use crate::compiler::program_manager::ProgramManager;


grammar<'input>(program_manager: &'input mut ProgramManager);

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::Program,
    "main" => Token::Main,
    "end" => Token::End,
    "print" => Token::Print,
    "var" => Token::Var,
    "void" => Token::Void,
    "while" => Token::While,
    "do" => Token::Do,
    "if" => Token::If,
    "else" => Token::Else,
    "id" => Token::Id(_String),
    "intType" => Token::IntDatatype,
    "floatType" => Token::FloatDatatype,
    "number" => Token::Number,
    "float" => Token::Float,
    "string" => Token::String,
    "+" => Token::OpAdd,
    "-" => Token::OpSub,
    "*" => Token::OpMul,
    "/" => Token::OpDiv,
    ">" => Token::Gt,
    "<" => Token::Lt,
    "!=" => Token::Ne,
    "=" => Token::Eq,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "," => Token::Comma,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,
    "." => Token::Dot,
  }

}

Cte: semantic_cube::Type = {
  <val: "number"> => semantic_cube::Type::Int,
  <val: "float"> => semantic_cube::Type::Float,
}

CteString: String = {
  <val: "string"> => val.to_string(),
}

OpAditivo: semantic_cube::Operator = {
  <op: "+"> => semantic_cube::Operator::Add,
  <op: "-"> => semantic_cube::Operator::Subtract,
}

OpMultiplicativo: semantic_cube::Operator = {
  <op: "*"> => semantic_cube::Operator::Multiply,
  <op: "/"> => semantic_cube::Operator::Divide,
}

OpLogico: semantic_cube::Operator = {
  <op: "<"> => semantic_cube::Operator::LessThan,
  <op: ">"> => semantic_cube::Operator::GreaterThan,
  <op: "!="> => semantic_cube::Operator::NotEqual,
}

//TODO: Build AST to return value
pub Expresion: (semantic_cube::Type, semantic_tables::VarValue) = {
  <left: Exp> <rest: ExpresionTail> => {
    let exp_type = rest.into_iter().fold(left, |acc, (op, right)| {
      program_manager.cubo.get_type(acc, op, right)
    });
    let value = semantic_tables::VarValue::Int(0);
    (exp_type, value)
  },
};

ExpresionTail: Vec<(semantic_cube::Operator, semantic_cube::Type)> = {
  <rest: (<OpLogico> <Exp>)*> =>  rest,
};

Exp: semantic_cube::Type = {
  <left: Exp> <op: OpAditivo> <right: Termino> => {
    program_manager.cubo.get_type(left, op, right)
  },
  <term: Termino> => term,
}

Termino: semantic_cube::Type = {
  <left: Termino> <op: OpMultiplicativo> <right: Factor> => {
    program_manager.cubo.get_type(left, op, right)
  },
  <factor: Factor> => factor
}

Factor: semantic_cube::Type = {
  "(" <exp: Expresion> ")" => exp.0,
  <op_add: OpAditivo> <val: Id> => {
    // Implement later with variable table
    semantic_cube::Type::Int
  
  },
  <val: Id> => {
    //TODO: Implement this
    // Implement later with variable table
    // Need to figure out where to check the current scope
    semantic_cube::Type::Int
  },
  Cte,
}

Statement: String = {
  <Assign> => "Assign".to_string(),
  <Condition>,
  <Cycle>,
  <Print>,
  <FCall>,
}

ExpList: Vec<(semantic_cube::Type, semantic_tables::VarValue)> = {
  <start: Expresion> <rest: ("," <Expresion>)*> => {
    rest
  }
}

Assign: () = {
  <id: Id> "=" <exp: Expresion> ";" => {

  },
}

PrintPrime: Vec<(semantic_cube::Type, semantic_tables::VarValue)> = {
  CteString => {
    vec!["CteString".to_string()];
    vec![(semantic_cube::Type::Int, semantic_tables::VarValue::Int(0))]
  },
  <args: ExpList> => args,
}

Print: String = {
  "print" "(" <PrintPrime> ")" ";" => "Print".to_string(),
}

Cycle: String = {
  "while" "(" <Expresion> ")" "do"  <Body>  => "Ciclo".to_string(), 
}

Condition: String = {
  "if" "(" <exp:Expresion> ")" <body: Body> ("else" <Body>)? => "Condition".to_string(),
}

FCall: String = {
  <id: Id> "(" <args: ExpList> ")" ";" => "FCall".to_string(),
}

Body: String = {
 "{" Statement* "}"  => "Body".to_string(),
}

Type: semantic_cube::Type = {
  <val: "intType"> => semantic_cube::Type::Int,
  <val: "floatType"> => semantic_cube::Type::Float,
}

Id: String = {
  <val: "id"> => {
    match val {
        Token::Id(ref name) => name.clone(),
        _ => panic!("Invalid identifier"),
      }
  },
}

// Modified to return a vector of identifiers
Identifier: Vec<String> = {
    <first: Id> <rest: ("," <Id>)*> => {
        let mut ids = vec![first];
        for id in rest {
            ids.push(id);
        }
        ids
    },
};

VarsPrime: Vec<semantic_tables::VariableInfo> = {
  <ids: Identifier> <colon: ":"> <val:Type> <semicolon: ";"> => {
    let mut variables_info = vec![];
    for id in ids {
      let id_value = id.clone();

      let _var_type: semantic_tables::VarType = match val {
        semantic_cube::Type::Int => semantic_tables::VarType::Int,
        semantic_cube::Type::Float => semantic_tables::VarType::Float,
        _ => panic!("Invalid type"),
      };
      let var_info: semantic_tables::VariableInfo = semantic_tables::VariableInfo 
        { value: match _var_type {
          semantic_tables::VarType::Int => semantic_tables::VarValue::Int(0),
          semantic_tables::VarType::Float => semantic_tables::VarValue::Float(0.0),
        }, var_type: _var_type, name: id_value.clone()  };
      
      variables_info.push(var_info);
    }   
    variables_info
  },    
}

Vars: Vec<Vec<semantic_tables::VariableInfo>> = {
  "var" <vars:VarsPrime+> => vars,
}

Param: semantic_tables::FunctionParam = {
  <id: Id> ":" <val: Type> => {
    let _var_type: semantic_tables::VarType = match val {
      semantic_cube::Type::Int => semantic_tables::VarType::Int,
      semantic_cube::Type::Float => semantic_tables::VarType::Float,
      _ => panic!("Invalid type"),
    };
    semantic_tables::FunctionParam { var_type: _var_type, name: id.clone() }
  },
}

Params: Vec<semantic_tables::FunctionParam> = {
  <first: Param> <rest: ("," <Param>)*> => {
    let mut param_vector = vec![first];
    for param in rest {
      param_vector.push(param);
    }
    param_vector
  },
}

FunctionId: String = {
  <id: Id> => {
    if program_manager.tabla_funciones.contains_key(&id) {
      panic!("Function Id: {} already registered", id);
    }
    id
  }
}

//TODO: Create analogic points to create the function into the function_table, 
// then add the params, and vars to the var_table of the function 
Funcs: () = {
  "void" <id: FunctionId> "(" <_params: Params> ")" "[" <vars: Vars?> <body:Body> "]" ";" => {
    program_manager.scope_stack.push(id.to_string());
    let mut temp_tabla_vars: HashMap<String, semantic_tables::VariableInfo> = HashMap::new();
    for param in &_params {
      if temp_tabla_vars.contains_key(&param.name) {
        panic!("Variable {} is already declared in the params of the function {}", param.name, id.to_string());
      }

      let var_info: semantic_tables::VariableInfo = semantic_tables::VariableInfo 
        { value: match param.var_type {
          semantic_tables::VarType::Int => semantic_tables::VarValue::Int(0),
          semantic_tables::VarType::Float => semantic_tables::VarValue::Float(0.0),
        }, var_type: param.var_type.clone(), name: param.name.clone()  };
        temp_tabla_vars.insert(param.name.clone(), var_info);
    }
    
    for var in vars.unwrap_or(vec![]) {
      for var_info in var {
        if program_manager.tabla_funciones.get("main").unwrap().vars.contains_key(&var_info.name){
          panic!("Variable {} in function {} is already declared as global", var_info.name, id.to_string());
        }

        if temp_tabla_vars.contains_key(&var_info.name) {
          panic!("Variable {} is already declared either in the params or in the function", var_info.name);
        }

        temp_tabla_vars.insert(var_info.name.clone(), var_info.clone());
      }
    }
    program_manager.tabla_funciones.insert(id.to_string(), semantic_tables::FunctionInfo { name: id.to_string(), params: _params, vars: temp_tabla_vars });
  },
}

VarsProgram: () = {
  <vars: Vars?> => {
    program_manager.scope_stack.push("main".to_string());
    let mut temp_tabla_vars: HashMap<String, semantic_tables::VariableInfo> = HashMap::new();
    for var in vars.unwrap_or(vec![]) {
      for var_info in var {
        if temp_tabla_vars.contains_key(&var_info.name){
          panic!("Global variable {} is already declared", var_info.name);
        }
        temp_tabla_vars.insert(var_info.name.clone(), var_info.clone());
      }
    }

    program_manager.tabla_funciones.insert("main".to_string(), semantic_tables::FunctionInfo { name: "main".to_string(), params: vec![], vars: temp_tabla_vars.clone() });
  },
}

pub Program: String = {
  "program" <id: Id> ";" <vars: VarsProgram> <funcs: Funcs*> <st_main: "main">  <body: Body>  <end: "end"> => format!("Program exit with value {}", 0),
}