use crate::tokens::{Token, LexicalError};

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::Program,
    "main" => Token::Main,
    "end" => Token::End,
    "print" => Token::Print,
    "var" => Token::Var,
    "void" => Token::Void,
    "while" => Token::While,
    "do" => Token::Do,
    "if" => Token::If,
    "else" => Token::Else,
    "id" => Token::Id,
    "intType" => Token::IntDatatype,
    "floatType" => Token::FloatDatatype,
    "number" => Token::Number,
    "float" => Token::Float,
    "string" => Token::String,
    "+" => Token::OpAdd,
    "-" => Token::OpSub,
    "*" => Token::OpMul,
    "/" => Token::OpDiv,
    ">" => Token::Gt,
    "<" => Token::Lt,
    "!=" => Token::Ne,
    "=" => Token::Eq,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "," => Token::Comma,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,
    "." => Token::Dot,
  }
}

Cte: String = {
  <val: "number"> => "Numero".to_string(),
  <val: "float"> => "Float".to_string()
}

CteString: String = {
  <val: "string"> => val.to_string(),
}

OpAditivo: String = {
  <op: "+"> => "+".to_string(),
  <op: "-"> => "-".to_string(),
}

OpMultiplicativo: String = {
  <op: "*"> => "*".to_string(),
  <op: "/"> => "/".to_string(),
}

OpLogico: String = {
  <op: "<"> => "<".to_string(),
  <op: ">"> => ">".to_string(),
  <op: "!="> => "!=".to_string(),
}

Expresion: String = {
  <left: Exp> <rest: ExpresionPrima> => format!("{} Expresion {}", left, rest),
}

ExpresionPrima: String = {
  => "".to_string(),
  <op: OpLogico> <right: Expresion> => "Expresion logica".to_string(),
}

Exp: String = {
  <left: Exp> <op: OpAditivo> <right: Termino> => "Exp aditivo".to_string(),
  <term: Termino> => "Exp simple".to_string(),
}

Termino: String = {
  <left: Termino> <op: OpMultiplicativo> <right: Factor> => "Termino multiplicativo".to_string(),
  <factor: Factor> => "Termino simple".to_string(),
}

Factor: String = {
  "(" <Expresion> ")" => "Primer Factor".to_string(),
  <opAdd: OpAditivo> <val: "id"> => "Factor con id".to_string(),
  <val: "id"> => "Factor con Id".to_string(),
  <Cte>,
}

Statement: String = {
  <Assign>,
  <Condition>,
  <Cycle>,
  <Print>,
  <FCall>,
}

ExpList: String = {
  <start: Expresion> "," <rest: ExpList> => format!("{} {}", start, rest),
  Expresion => "Single Expresion".to_string(),
}

Assign: String = {
  <id: "id"> "=" <exp: Expresion> ";" => "Assign".to_string(),
}

PrintPrime: String = {
  CteString,
  <args: ExpList> => format!("{}", args),
}

Print: String = {
  "print" "(" <PrintPrime> ")" ";"
}

Cycle: String = {
  "while" "(" <Expresion> ")" "do"  <Body>  => "Ciclo".to_string(), 
}

Condition: String = {
  "if" "(" <exp:Expresion> ")" <body: Body> ("else" <Body>)? => "Condition".to_string(),
}

FCall: String = {
  <id: "id"> "(" <args: ExpList> ")" ";" => "FCall".to_string(),
}

Body: String = {
 "{" Statement* "}"  => "Body".to_string(),
}

Type: String = {
  <val: "intType"> => val.to_string(),
  <val: "floatType"> => val.to_string(),
}

IdentifierPrime: String = {
  => "".to_string(),
  "," <Identifier> => "Identifier Prime".to_string(),
}

Identifier: String = {
  <id: "id"> <id_prime: IdentifierPrime> => id.to_string() + &id_prime,
}

VarsPrime: String = {
  <Identifier>,
  <id: Identifier> <colon: ":"> <val:Type> <semicolon: ";"> => "Type var".to_string(),
}

Vars: String = {
  "var" <VarsPrime+> => "Vars".to_string(),
}

Param: String = {
  <id: "id"> ":" <val: Type> => "Param".to_string(),
}

Params: String = {
  Param ("," Param)* => "Params".to_string(),
}

Funcs: String = {
  "void" <id: "id"> "(" <params: Params> ")" "[" <vars: Vars*> <body:Body> "]" ";" => "Funcion".to_string(),
}

VarsProgram: String = {
  Vars* => "Vars Program".to_string(),
}

FuncsProgram: String = {
  Funcs* => "Funciones del programa".to_string(),
}

pub Program: String = {
  "program" <id: "id"> ";" <vars: VarsProgram> <funcs: FuncsProgram> <main:"main"> <body: Body>  <end: "end"> => format!("Programa Valido"),
}