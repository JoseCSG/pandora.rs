use crate::tokens::{Token, LexicalError};
use crate::semantic_cube;

grammar<'input>(cubo: &'input semantic_cube::CuboSemantico);

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::Program,
    "main" => Token::Main,
    "end" => Token::End,
    "print" => Token::Print,
    "var" => Token::Var,
    "void" => Token::Void,
    "while" => Token::While,
    "do" => Token::Do,
    "if" => Token::If,
    "else" => Token::Else,
    "id" => Token::Id,
    "intType" => Token::IntDatatype,
    "floatType" => Token::FloatDatatype,
    "number" => Token::Number,
    "float" => Token::Float,
    "string" => Token::String,
    "+" => Token::OpAdd,
    "-" => Token::OpSub,
    "*" => Token::OpMul,
    "/" => Token::OpDiv,
    ">" => Token::Gt,
    "<" => Token::Lt,
    "!=" => Token::Ne,
    "=" => Token::Eq,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "," => Token::Comma,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,
    "." => Token::Dot,
  }

}

Cte: semantic_cube::Type = {
  <val: "number"> => semantic_cube::Type::Int,
  <val: "float"> => semantic_cube::Type::Float,
}

CteString: String = {
  <val: "string"> => val.to_string(),
}

OpAditivo: semantic_cube::Operator = {
  <op: "+"> => semantic_cube::Operator::Add,
  <op: "-"> => semantic_cube::Operator::Subtract,
}

OpMultiplicativo: semantic_cube::Operator = {
  <op: "*"> => semantic_cube::Operator::Multiply,
  <op: "/"> => semantic_cube::Operator::Divide,
}

OpLogico: semantic_cube::Operator = {
  <op: "<"> => semantic_cube::Operator::LessThan,
  <op: ">"> => semantic_cube::Operator::GreaterThan,
  <op: "!="> => semantic_cube::Operator::NotEqual,
}

pub Expresion: semantic_cube::Type = {
  <left: Exp> <rest: ExpresionTail> => {
    rest.into_iter().fold(left, |acc, (op, right)| {
      cubo.get_type(acc, op, right)
    })
  },
};

ExpresionTail: Vec<(semantic_cube::Operator, semantic_cube::Type)> = {
  <rest: (<OpLogico> <Exp>)*> =>  rest,
};

Exp: semantic_cube::Type = {
  <left: Exp> <op: OpAditivo> <right: Termino> => {
    cubo.get_type(left, op, right)
  },
  <term: Termino> => term,
}

Termino: semantic_cube::Type = {
  <left: Termino> <op: OpMultiplicativo> <right: Factor> => {
    cubo.get_type(left, op, right)
  },
  <factor: Factor> => factor
}

Factor: semantic_cube::Type = {
  "(" <exp: Expresion> ")" => exp,
  <opAdd: OpAditivo> <val: "id"> => {
    // Implement later with variable table
    semantic_cube::Type::Int
  
  },
  <val:"id"> => {
    // Implement later with variable table
    semantic_cube::Type::Int
  },
  Cte,
}

Statement: String = {
  <Assign>,
  <Condition>,
  <Cycle>,
  <Print>,
  <FCall>,
}

ExpList: String = {
  <start: Expresion> "," <rest: ExpList> => {
    rest
  },
  Expresion => "Single Expresion".to_string(),
}

Assign: String = {
  <id: "id"> "=" <exp: Expresion> ";" => "Assign".to_string(),
}

PrintPrime: String = {
  CteString,
  <args: ExpList> => format!("{}", args),
}

Print: String = {
  "print" "(" <PrintPrime> ")" ";"
}

Cycle: String = {
  "while" "(" <Expresion> ")" "do"  <Body>  => "Ciclo".to_string(), 
}

Condition: String = {
  "if" "(" <exp:Expresion> ")" <body: Body> ("else" <Body>)? => "Condition".to_string(),
}

FCall: String = {
  <id: "id"> "(" <args: ExpList> ")" ";" => "FCall".to_string(),
}

Body: String = {
 "{" Statement* "}"  => "Body".to_string(),
}

Type: String = {
  <val: "intType"> => val.to_string(),
  <val: "floatType"> => val.to_string(),
}

IdentifierPrime: String = {
  => "".to_string(),
  "," <Identifier> => "Identifier Prime".to_string(),
}

Identifier: String = {
  <id: "id"> <id_prime: IdentifierPrime> => id.to_string() + &id_prime,
}

VarsPrime: String = {
  <Identifier>,
  <id: Identifier> <colon: ":"> <val:Type> <semicolon: ";"> => "Type var".to_string(),
}

Vars: String = {
  "var" <VarsPrime+> => "Vars".to_string(),
}

Param: String = {
  <id: "id"> ":" <val: Type> => "Param".to_string(),
}

Params: String = {
  Param ("," Param)* => "Params".to_string(),
}

Funcs: String = {
  "void" <id: "id"> "(" <params: Params> ")" "[" <vars: Vars*> <body:Body> "]" ";" => "Funcion".to_string(),
}

VarsProgram: String = {
  Vars* => "Vars Program".to_string(),
}

FuncsProgram: String = {
  Funcs* => "Funciones del programa".to_string(),
}

pub Program: String = {
  "program" <id: "id"> ";" <vars: VarsProgram> <funcs: FuncsProgram> <main:"main"> <body: Body>  <end: "end"> => format!("Programa Valido"),
}